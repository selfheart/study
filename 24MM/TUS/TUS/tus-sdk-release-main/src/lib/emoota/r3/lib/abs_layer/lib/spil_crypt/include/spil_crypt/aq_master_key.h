/* ****************************************************************************
 *
 *         AIRBIQUITY INC. PROPRIETARY AND CONFIDENTIAL INFORMATION
 *
 *  The software and information contained herein is the proprietary and
 *  confidential property of Airbiquity Inc. and shall not be disclosed
 *  in whole or in part. Possession, use, reproduction or transfer of
 *  this software and information is prohibited without the express written
 *  permission of Airbiquity Inc.
 *
 *  Copyright (c) 2017 Airbiquity Inc.  All rights reserved.
 *
 * ****************************************************************************
 */


/**
 * @file aq_master_key.h
 *
 * This file defines functions utilizing the *master key* (per ECU key).
 * Implementation of those functions are platform dependent. It is preferred that those functions
 * utilize some kind of system security features such as TrustZone or HSM to protect the private
 * key of the master key.
 *
 * In an ideal scenario, the private key of master key is never accessible by software, even the
 * code implementing these functions themselves. The private key should only be accessible by
 * HSM to do the crypto operation.
 */

#ifndef LIB_SECURITY_H_AQ_MASTER_KEY_H_
#define LIB_SECURITY_H_AQ_MASTER_KEY_H_

typedef struct for_crypt_master_key_ctx crypt_master_key_ctx_t;

#ifdef ALLOW_KEY_PROVISION
/**
 * @brief Generate master key pair and CSR.
 *
 * This function generates the key pair and returns a CSR that can be used
 * for a server to sign the certificate.
 * This function should only exists when ALLOW_KEY_PROVISION is defined. It should not be enabled
 * in application runs normally.
 * It should only be enabled in special key provisioning tool.
 * @public
 * @param [in] subj_name subject name to put in the CSR
 * @param [in] csr buffer for the CSR
 * @buflen [in] size of the buffer. The caller is responsible to make sure the buffer is big enough
 * @return EXIT_SUCCESS or error code
 */
err_t crypt_provision_master_key(const uint8_t *subj_name,
        uint8_t *csr, size_t buflen);

/**
 * @brief Process signed cert chain and finish provisioning master key
 *
 * Callback function when the CSR is processed by the server and a signed cert chain is received.
 *
 * @public
 * @param [in] cert_chain signed certificate chain from the server
 * @return EXIT_SUCCESS or error code
 */
err_t crypt_on_master_certificate_signed(const uint8_t *cert_chain);
#endif

/**
 * @brief Get information of the master key.
 *
 * @public
 * @param [out] max_siglen to get the maximum length of the signature generated by the master key
 * @param [out] max_keyid_len to get the maximum length of the keyID of the master key
 * @param [out] method_len to get the length of the default signing method by the master key
 * @return EXIT_SUCCESS or error code
 */
err_t crypt_get_master_key_info(size_t *max_siglen, size_t *max_keyid_len, size_t *method_len);

/**
 * @brief Sign with the master key.
 *
 * Generate signature with the master key.
 * Caller is responsible for having big enough buffers for all the data.
 * The size of the buffers required is returned by crypt_get_master_key_info()
 *
 * @public
 * @param [in] data to be signed
 * @param [in] datalen size of the data
 * @param [in] sig buffer for signature
 * @param [in] sigbuflen size of the signature buffer
 * @param [out] siglen size of the signature generated
 * @param [in] keyid buffer for the keyID of the master key
 * @param [in] keyidbuflen size of the keyID buffer
 * @param [out] keyidlen size of the public key returned
 * @param [in] method method of signing
 * @param [in] method_buf_len size of the method buffer
 * @return EXIT_SUCCESS or error code
 */
err_t crypt_sign_with_master_key(const uint8_t *data, size_t datalen,
        uint8_t *sig, size_t sigbuflen, size_t *siglen,
        uint8_t *keyid, size_t keyidbuflen, size_t *keyidlen,
        uint8_t *method, size_t method_buf_len);

/**
 * @brief Decrypt with the master key.
 *
 * @public
 * @param [in] encrypted input data
 * @param [in] ilen length of input data
 * @param [in] output buffer for the output data
 * @param [in] buflen buffer size
 * @param [out] olen size of decrypted data
 * @param [in] padding Padding scheme used to encrypt
 * @param [in] padding_md hash mode (used for some of the padding scheme)
 * @return EXIT_SUCCESS or error code
 */
err_t crypt_decrypt_with_master_key(const uint8_t *encrypted, size_t ilen,
        uint8_t *output, size_t buflen, size_t *olen,
        crypt_padding_t padding, crypt_hash_mode_t padding_md);

#endif /* LIB_SECURITY_H_AQ_MASTER_KEY_H_ */
