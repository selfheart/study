/* ****************************************************************************
 *
 *         AIRBIQUITY INC. PROPRIETARY AND CONFIDENTIAL INFORMATION
 *
 *  The software and information contained herein is the proprietary and
 *  confidential property of Airbiquity Inc. and shall not be disclosed
 *  in whole or in part. Possession, use, reproduction or transfer of
 *  this software and information is prohibited without the express written
 *  permission of Airbiquity Inc.
 *
 *  Copyright (c) 2019 Airbiquity Inc.  All rights reserved.
 *
 * ****************************************************************************
 */
/**
 * @file item_writers.h
 * @date Jan 14, 2019
 * @author mvogel
 * @copyright Airbiquity, Inc.
 *
 * @brief TODO
 *
 */

#ifndef ONTRAC_REST_ITEM_WRITERS_H_
#define ONTRAC_REST_ITEM_WRITERS_H_

#include <ontrac/ontrac/traverser.h>
#include <ontrac/stream/datasink.h>

typedef struct for_item_writer item_writer_t;

/**
 * @brief callback used to notify user each time some raw data was successfully formatted by the item_writer_t
 *
 * @param ctx: the callback context passed in alongside the callback
 * @param item_state: current state of the serialized item resulting in the given data
 * @param rawdata: formatted data written to the destination after being generated by the item_writer_t
 * @param amount: number of bytes in rawdata that where consumed by the parser
 * @return EXIT_SUCCESS to continue formatted, else an error code to indicate formatting should stop.
 */
typedef err_t (*on_data_formatted_t) (cvar_t ctx,
        traverser_t *item_state, const byte_t *rawdata, size_t amount);
/**
 * @brief typedef for a function used to serialize an item state into the output buffer
 *    Capable of sequential partial writes of the item state to an output buffer as the buffer fills and empties
 *
 * @param writer: used to track which parts of the item have already been written to the output buffer
 * @param output_buf: collected formatted data generated be the item-writer implementation
 * @return EOVERFLOW: if the buffer is full and needs to be emptied so that more data can be formatted
 * @return ECANCELED when the item-state has been completely written into the output buffer
 */
typedef err_t (*format_data_func_t) (item_writer_t *writer, byte_buffer_t *output_buf);

struct for_item_writer {
    /** State of the serializable item, keeping track of what serialized and what comes next */
    traverser_t* item_state;
    /** decodes internal UTF8 strings into unicode and keeps track of the state */
    abq_decoder_t decoder;
    /** encodes unicode into formatted/escaped for the given language */
    abq_encoder_t encoder;
    /** Cache used to store partially encoded data before writing it out */
    byte_buffer_t *cache;
    /** function pointer used to format data as it becomes available */
    format_data_func_t format_into;
    /** Optional callback to be invoked each time data is successfully formatted to buffer */
    on_data_formatted_t on_format;
    cvar_t format_ctx;
    /** Indent each field according to depth of the traverser (a.k.a. pretty-print) */
    bool_t indent;
};

extern format_data_func_t abq_lookup_formatter(cstr_t mime_type);
/**
 * @brief allocates an instance of an item_writer_t with a self reference
 *
 * @param formatter: a format_data_func_t used to format item data
 * @param item: item to be formated (serialized) into a octet-stream
 * @param cache: A byte_buffer_t* used to hold processed data
 * @param indent: boolean used to indicate if pretty-printing is desired
 * @param on_format: Optional callback used to collect / inspect / verify each snippet of formatted data in a streaming fashion
 * @param format_ctx: a callback context to be passed to on_format function when invoked
 * @return pointer to newly allocated instance of a item_writer_t item
 */
extern item_writer_t* item_writer_create(format_data_func_t formatter, cvar_t item,
        byte_buffer_t* cache, bool_t indent, on_data_formatted_t on_format, cvar_t format_ctx);
/**
 * @brief sets up a datawriter to write data into a datasink_t as it becomes writable
 *
 * @param serializer: pointer to a item_writer_t used to format data before writing into sink
 * @param dest: pointer to a datasink_t used to send data to it's final destination(s) if any
 * @return EXIT_SUCCESS if all data has been serialized and written to sink
 * @return EINPROGREES if successful but listening for ABQ_IO_WRITE events before writing remaining data
 * @return other: error occurred
 */
extern err_t item_writer_set_sink(const item_writer_t* serializer, datasink_t* dest);
/**
 * @breif create a datatap_t used to pull formatted data from an item + formatter
 *
 * @param formatter: The format function used to format data read from the tap
 * @param item: the item to be serialized via the formatter
 * @return A datatap used to pull formatted item data or NULL on error
 */
extern datatap_t * item_tap_create(format_data_func_t formatter, cvar_t item);

/**
 * @brief resolves an instance of item_writer_class to the item_writer_t*
 *
 * @param pointer to item to be resolved
 * @return resolved item_writer_t* or NULL on failure
 */
extern item_writer_t* item_writer_resolve(cvar_t item);
/**
 * @brief serializes (for external transfer) supported data into JSON formatted data which is written to the datasink_t
 *
 * @param dest: pointer to an datasink_t to which the serialized data will be written
 * @param item: A serializable item, often defined with DEFINE_SERIALIZABLE_CLASSRIALIZABLE_CLASS
 * @param indent: flag used to control pretty-printing of the JSON content
 * @return EXIT_SUCCESS to indicate that item has been fully written to the datasink_t
 * @return EINPROGRESS to indicate that datasink_t is fully cached, but not flushed through the stream
 * @return else different error code for failure
 */
err_t datasink_write_json(datasink_t* dest, cvar_t item, bool_t indent);
/**
 * @brief writes a instance of a serializable class to the destination buffer
 *
 * @param item: instance to serialize, should have a class defined with DEFINE_SERIALIZABLE_CLASS
 * @param dest: byte array used to store the resulting data
 * @param max_bytes: maximum number of bytes that can be written to the dest buffer
 * @param indent: flag used to control pretty-printing of the JSON content
 * @return number of bytes written to the destination buffer, or -1 or failure with errno is set.
 */

extern int32_t json_format_data(cvar_t item, byte_t *dest, int32_t max_bytes, bool_t indent);
static inline  int32_t json_format_str(cvar_t item, byte_t *dest, int32_t max_bytes) {
#ifndef NDEBUG
    return json_format_data(item, dest, max_bytes, true);
#else
    return json_format_data(item, dest, max_bytes, false);
#endif /* NDEBUG */
}
/**
 * @brief A JSON formatter implementation for format_data_func_t
 *
 * @param writer: used to track which parts of the item have already been written to the output buffer
 * @param output_buf: collected formatted data generated be the item-writer implementation
 * @return EOVERFLOW: if the buffer is full and needs to be emptied so that more data can be formatted
 * @return ECANCELED when the item-state has been completely written into the output buffer
 */
extern err_t json_writer_format_data(item_writer_t *writer, byte_buffer_t *output_buf);

#endif /* ONTRAC_REST_ITEM_WRITERS_H_ */
